// THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
// Source: lure.proto
/* eslint-disable */

import type { ByteSource } from "protoscript";
import { BinaryReader, BinaryWriter } from "protoscript";
import { JSONrequest, PBrequest } from "twirpscript";
// This is the minimum version supported by the current runtime.
// If this line fails typechecking, breaking changes have been introduced and this
// file needs to be regenerated by running `npx twirpscript`.
export { MIN_SUPPORTED_VERSION_0_0_56 } from "twirpscript";
import type { ClientConfiguration } from "twirpscript";

//========================================//
//                 Types                  //
//========================================//

/**
 * SORT_BY represents possible things to sort packages by
 */
export type SORT_BY = "UNSORTED" | "NAME" | "REPOSITORY" | "VERSION";

/**
 * FILTER_TYPE represents possible filters for packages
 */
export type FILTER_TYPE = "NO_FILTER" | "IN_REPOSITORY" | "SUPPORTS_ARCH";

/**
 * SearchRequest is a request to search for packages
 */
export interface SearchRequest {
  query: string;
  limit: bigint;
  sortBy: SORT_BY;
  filterType: FILTER_TYPE;
  filterValue?: string | null | undefined;
}

/**
 * StringList contains a list of strings
 */
export interface StringList {
  entries: string[];
}

/**
 * Package represents a LURE package
 */
export interface Package {
  name: string;
  repository: string;
  version: string;
  release: bigint;
  epoch?: bigint | null | undefined;
  description?: string | null | undefined;
  homepage?: string | null | undefined;
  maintainer?: string | null | undefined;
  architectures: string[];
  licenses: string[];
  provides: string[];
  conflicts: string[];
  replaces: string[];
  depends: Record<string, Package.Depends["value"] | undefined>;
  buildDepends: Record<string, Package.BuildDepends["value"] | undefined>;
}

export declare namespace Package {
  interface Depends {
    key: string;
    value: StringList;
  }

  interface BuildDepends {
    key: string;
    value: StringList;
  }
}

export interface GetPackageRequest {
  name: string;
  repository: string;
}

/**
 * SearchResponse contains returned packages
 */
export interface SearchResponse {
  packages: Package[];
}

export interface GetBuildScriptRequest {
  name: string;
  repository: string;
}

export interface GetBuildScriptResponse {
  script: string;
}

//========================================//
//          API Protobuf Client           //
//========================================//

/**
 * Search searches through LURE packages in the database
 */
export async function Search(
  searchRequest: SearchRequest,
  config?: ClientConfiguration
): Promise<SearchResponse> {
  const response = await PBrequest(
    "/lure.API/Search",
    SearchRequest.encode(searchRequest),
    config
  );
  return SearchResponse.decode(response);
}

/**
 * GetPkg gets a single LURE package from the database
 */
export async function GetPkg(
  getPackageRequest: GetPackageRequest,
  config?: ClientConfiguration
): Promise<Package> {
  const response = await PBrequest(
    "/lure.API/GetPkg",
    GetPackageRequest.encode(getPackageRequest),
    config
  );
  return Package.decode(response);
}

/**
 * GetBuildScript returns the build script for the given package
 */
export async function GetBuildScript(
  getBuildScriptRequest: GetBuildScriptRequest,
  config?: ClientConfiguration
): Promise<GetBuildScriptResponse> {
  const response = await PBrequest(
    "/lure.API/GetBuildScript",
    GetBuildScriptRequest.encode(getBuildScriptRequest),
    config
  );
  return GetBuildScriptResponse.decode(response);
}

//========================================//
//            API JSON Client             //
//========================================//

/**
 * Search searches through LURE packages in the database
 */
export async function SearchJSON(
  searchRequest: SearchRequest,
  config?: ClientConfiguration
): Promise<SearchResponse> {
  const response = await JSONrequest(
    "/lure.API/Search",
    SearchRequestJSON.encode(searchRequest),
    config
  );
  return SearchResponseJSON.decode(response);
}

/**
 * GetPkg gets a single LURE package from the database
 */
export async function GetPkgJSON(
  getPackageRequest: GetPackageRequest,
  config?: ClientConfiguration
): Promise<Package> {
  const response = await JSONrequest(
    "/lure.API/GetPkg",
    GetPackageRequestJSON.encode(getPackageRequest),
    config
  );
  return PackageJSON.decode(response);
}

/**
 * GetBuildScript returns the build script for the given package
 */
export async function GetBuildScriptJSON(
  getBuildScriptRequest: GetBuildScriptRequest,
  config?: ClientConfiguration
): Promise<GetBuildScriptResponse> {
  const response = await JSONrequest(
    "/lure.API/GetBuildScript",
    GetBuildScriptRequestJSON.encode(getBuildScriptRequest),
    config
  );
  return GetBuildScriptResponseJSON.decode(response);
}

//========================================//
//                  API                   //
//========================================//

/**
 * Web is the LURE Web service
 */
export interface API<Context = unknown> {
  /**
   * Search searches through LURE packages in the database
   */
  Search: (
    searchRequest: SearchRequest,
    context: Context
  ) => Promise<SearchResponse> | SearchResponse;
  /**
   * GetPkg gets a single LURE package from the database
   */
  GetPkg: (
    getPackageRequest: GetPackageRequest,
    context: Context
  ) => Promise<Package> | Package;
  /**
   * GetBuildScript returns the build script for the given package
   */
  GetBuildScript: (
    getBuildScriptRequest: GetBuildScriptRequest,
    context: Context
  ) => Promise<GetBuildScriptResponse> | GetBuildScriptResponse;
}

export function createAPI<Context>(service: API<Context>) {
  return {
    name: "lure.API",
    methods: {
      Search: {
        name: "Search",
        handler: service.Search,
        input: { protobuf: SearchRequest, json: SearchRequestJSON },
        output: { protobuf: SearchResponse, json: SearchResponseJSON },
      },
      GetPkg: {
        name: "GetPkg",
        handler: service.GetPkg,
        input: { protobuf: GetPackageRequest, json: GetPackageRequestJSON },
        output: { protobuf: Package, json: PackageJSON },
      },
      GetBuildScript: {
        name: "GetBuildScript",
        handler: service.GetBuildScript,
        input: {
          protobuf: GetBuildScriptRequest,
          json: GetBuildScriptRequestJSON,
        },
        output: {
          protobuf: GetBuildScriptResponse,
          json: GetBuildScriptResponseJSON,
        },
      },
    },
  } as const;
}

//========================================//
//        Protobuf Encode / Decode        //
//========================================//

export const SORT_BY = {
  UNSORTED: "UNSORTED",
  NAME: "NAME",
  REPOSITORY: "REPOSITORY",
  VERSION: "VERSION",
  /**
   * @private
   */
  _fromInt: function (i: number): SORT_BY {
    switch (i) {
      case 0: {
        return "UNSORTED";
      }
      case 1: {
        return "NAME";
      }
      case 2: {
        return "REPOSITORY";
      }
      case 3: {
        return "VERSION";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as SORT_BY;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: SORT_BY): number {
    switch (i) {
      case "UNSORTED": {
        return 0;
      }
      case "NAME": {
        return 1;
      }
      case "REPOSITORY": {
        return 2;
      }
      case "VERSION": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const FILTER_TYPE = {
  NO_FILTER: "NO_FILTER",
  IN_REPOSITORY: "IN_REPOSITORY",
  SUPPORTS_ARCH: "SUPPORTS_ARCH",
  /**
   * @private
   */
  _fromInt: function (i: number): FILTER_TYPE {
    switch (i) {
      case 0: {
        return "NO_FILTER";
      }
      case 1: {
        return "IN_REPOSITORY";
      }
      case 2: {
        return "SUPPORTS_ARCH";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as FILTER_TYPE;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: FILTER_TYPE): number {
    switch (i) {
      case "NO_FILTER": {
        return 0;
      }
      case "IN_REPOSITORY": {
        return 1;
      }
      case "SUPPORTS_ARCH": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const SearchRequest = {
  /**
   * Serializes SearchRequest to protobuf.
   */
  encode: function (msg: Partial<SearchRequest>): Uint8Array {
    return SearchRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes SearchRequest from protobuf.
   */
  decode: function (bytes: ByteSource): SearchRequest {
    return SearchRequest._readMessage(
      SearchRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes SearchRequest with all fields set to their default value.
   */
  initialize: function (): SearchRequest {
    return {
      query: "",
      limit: 0n,
      sortBy: SORT_BY._fromInt(0),
      filterType: FILTER_TYPE._fromInt(0),
      filterValue: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SearchRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.query) {
      writer.writeString(1, msg.query);
    }
    if (msg.limit) {
      writer.writeInt64String(2, msg.limit.toString() as any);
    }
    if (msg.sortBy && SORT_BY._toInt(msg.sortBy)) {
      writer.writeEnum(3, SORT_BY._toInt(msg.sortBy));
    }
    if (msg.filterType && FILTER_TYPE._toInt(msg.filterType)) {
      writer.writeEnum(4, FILTER_TYPE._toInt(msg.filterType));
    }
    if (msg.filterValue != undefined) {
      writer.writeString(5, msg.filterValue);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SearchRequest,
    reader: BinaryReader
  ): SearchRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.query = reader.readString();
          break;
        }
        case 2: {
          msg.limit = BigInt(reader.readInt64String());
          break;
        }
        case 3: {
          msg.sortBy = SORT_BY._fromInt(reader.readEnum());
          break;
        }
        case 4: {
          msg.filterType = FILTER_TYPE._fromInt(reader.readEnum());
          break;
        }
        case 5: {
          msg.filterValue = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const StringList = {
  /**
   * Serializes StringList to protobuf.
   */
  encode: function (msg: Partial<StringList>): Uint8Array {
    return StringList._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes StringList from protobuf.
   */
  decode: function (bytes: ByteSource): StringList {
    return StringList._readMessage(
      StringList.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes StringList with all fields set to their default value.
   */
  initialize: function (): StringList {
    return {
      entries: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<StringList>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.entries?.length) {
      writer.writeRepeatedString(1, msg.entries);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: StringList, reader: BinaryReader): StringList {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.entries.push(reader.readString());
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const Package = {
  /**
   * Serializes Package to protobuf.
   */
  encode: function (msg: Partial<Package>): Uint8Array {
    return Package._writeMessage(msg, new BinaryWriter()).getResultBuffer();
  },

  /**
   * Deserializes Package from protobuf.
   */
  decode: function (bytes: ByteSource): Package {
    return Package._readMessage(Package.initialize(), new BinaryReader(bytes));
  },

  /**
   * Initializes Package with all fields set to their default value.
   */
  initialize: function (): Package {
    return {
      name: "",
      repository: "",
      version: "",
      release: 0n,
      epoch: undefined,
      description: undefined,
      homepage: undefined,
      maintainer: undefined,
      architectures: [],
      licenses: [],
      provides: [],
      conflicts: [],
      replaces: [],
      depends: {},
      buildDepends: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<Package>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.repository) {
      writer.writeString(2, msg.repository);
    }
    if (msg.version) {
      writer.writeString(3, msg.version);
    }
    if (msg.release) {
      writer.writeInt64String(4, msg.release.toString() as any);
    }
    if (msg.epoch != undefined) {
      writer.writeInt64String(5, msg.epoch.toString() as any);
    }
    if (msg.description != undefined) {
      writer.writeString(6, msg.description);
    }
    if (msg.homepage != undefined) {
      writer.writeString(7, msg.homepage);
    }
    if (msg.maintainer != undefined) {
      writer.writeString(8, msg.maintainer);
    }
    if (msg.architectures?.length) {
      writer.writeRepeatedString(9, msg.architectures);
    }
    if (msg.licenses?.length) {
      writer.writeRepeatedString(10, msg.licenses);
    }
    if (msg.provides?.length) {
      writer.writeRepeatedString(11, msg.provides);
    }
    if (msg.conflicts?.length) {
      writer.writeRepeatedString(12, msg.conflicts);
    }
    if (msg.replaces?.length) {
      writer.writeRepeatedString(13, msg.replaces);
    }
    if (msg.depends) {
      writer.writeRepeatedMessage(
        14,
        Object.entries(msg.depends).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        Package.Depends._writeMessage
      );
    }
    if (msg.buildDepends) {
      writer.writeRepeatedMessage(
        15,
        Object.entries(msg.buildDepends).map(([key, value]) => ({
          key: key as any,
          value: value as any,
        })) as any,
        Package.BuildDepends._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Package, reader: BinaryReader): Package {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.repository = reader.readString();
          break;
        }
        case 3: {
          msg.version = reader.readString();
          break;
        }
        case 4: {
          msg.release = BigInt(reader.readInt64String());
          break;
        }
        case 5: {
          msg.epoch = BigInt(reader.readInt64String());
          break;
        }
        case 6: {
          msg.description = reader.readString();
          break;
        }
        case 7: {
          msg.homepage = reader.readString();
          break;
        }
        case 8: {
          msg.maintainer = reader.readString();
          break;
        }
        case 9: {
          msg.architectures.push(reader.readString());
          break;
        }
        case 10: {
          msg.licenses.push(reader.readString());
          break;
        }
        case 11: {
          msg.provides.push(reader.readString());
          break;
        }
        case 12: {
          msg.conflicts.push(reader.readString());
          break;
        }
        case 13: {
          msg.replaces.push(reader.readString());
          break;
        }
        case 14: {
          const map = {} as Package.Depends;
          reader.readMessage(map, Package.Depends._readMessage);
          msg.depends[map.key.toString()] = map.value;
          break;
        }
        case 15: {
          const map = {} as Package.BuildDepends;
          reader.readMessage(map, Package.BuildDepends._readMessage);
          msg.buildDepends[map.key.toString()] = map.value;
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },

  Depends: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Package.Depends>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, StringList._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Package.Depends,
      reader: BinaryReader
    ): Package.Depends {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = StringList.initialize();
            reader.readMessage(msg.value, StringList._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },

  BuildDepends: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Package.BuildDepends>,
      writer: BinaryWriter
    ): BinaryWriter {
      if (msg.key) {
        writer.writeString(1, msg.key);
      }
      if (msg.value) {
        writer.writeMessage(2, msg.value, StringList._writeMessage);
      }
      return writer;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Package.BuildDepends,
      reader: BinaryReader
    ): Package.BuildDepends {
      while (reader.nextField()) {
        const field = reader.getFieldNumber();
        switch (field) {
          case 1: {
            msg.key = reader.readString();
            break;
          }
          case 2: {
            msg.value = StringList.initialize();
            reader.readMessage(msg.value, StringList._readMessage);
            break;
          }
          default: {
            reader.skipField();
            break;
          }
        }
      }
      return msg;
    },
  },
};

export const GetPackageRequest = {
  /**
   * Serializes GetPackageRequest to protobuf.
   */
  encode: function (msg: Partial<GetPackageRequest>): Uint8Array {
    return GetPackageRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetPackageRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetPackageRequest {
    return GetPackageRequest._readMessage(
      GetPackageRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetPackageRequest with all fields set to their default value.
   */
  initialize: function (): GetPackageRequest {
    return {
      name: "",
      repository: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetPackageRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.repository) {
      writer.writeString(2, msg.repository);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetPackageRequest,
    reader: BinaryReader
  ): GetPackageRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.repository = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const SearchResponse = {
  /**
   * Serializes SearchResponse to protobuf.
   */
  encode: function (msg: Partial<SearchResponse>): Uint8Array {
    return SearchResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes SearchResponse from protobuf.
   */
  decode: function (bytes: ByteSource): SearchResponse {
    return SearchResponse._readMessage(
      SearchResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes SearchResponse with all fields set to their default value.
   */
  initialize: function (): SearchResponse {
    return {
      packages: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SearchResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.packages?.length) {
      writer.writeRepeatedMessage(
        1,
        msg.packages as any,
        Package._writeMessage
      );
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: SearchResponse,
    reader: BinaryReader
  ): SearchResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          const m = Package.initialize();
          reader.readMessage(m, Package._readMessage);
          msg.packages.push(m);
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetBuildScriptRequest = {
  /**
   * Serializes GetBuildScriptRequest to protobuf.
   */
  encode: function (msg: Partial<GetBuildScriptRequest>): Uint8Array {
    return GetBuildScriptRequest._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetBuildScriptRequest from protobuf.
   */
  decode: function (bytes: ByteSource): GetBuildScriptRequest {
    return GetBuildScriptRequest._readMessage(
      GetBuildScriptRequest.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetBuildScriptRequest with all fields set to their default value.
   */
  initialize: function (): GetBuildScriptRequest {
    return {
      name: "",
      repository: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetBuildScriptRequest>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.name) {
      writer.writeString(1, msg.name);
    }
    if (msg.repository) {
      writer.writeString(2, msg.repository);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetBuildScriptRequest,
    reader: BinaryReader
  ): GetBuildScriptRequest {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.name = reader.readString();
          break;
        }
        case 2: {
          msg.repository = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

export const GetBuildScriptResponse = {
  /**
   * Serializes GetBuildScriptResponse to protobuf.
   */
  encode: function (msg: Partial<GetBuildScriptResponse>): Uint8Array {
    return GetBuildScriptResponse._writeMessage(
      msg,
      new BinaryWriter()
    ).getResultBuffer();
  },

  /**
   * Deserializes GetBuildScriptResponse from protobuf.
   */
  decode: function (bytes: ByteSource): GetBuildScriptResponse {
    return GetBuildScriptResponse._readMessage(
      GetBuildScriptResponse.initialize(),
      new BinaryReader(bytes)
    );
  },

  /**
   * Initializes GetBuildScriptResponse with all fields set to their default value.
   */
  initialize: function (): GetBuildScriptResponse {
    return {
      script: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetBuildScriptResponse>,
    writer: BinaryWriter
  ): BinaryWriter {
    if (msg.script) {
      writer.writeString(1, msg.script);
    }
    return writer;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetBuildScriptResponse,
    reader: BinaryReader
  ): GetBuildScriptResponse {
    while (reader.nextField()) {
      const field = reader.getFieldNumber();
      switch (field) {
        case 1: {
          msg.script = reader.readString();
          break;
        }
        default: {
          reader.skipField();
          break;
        }
      }
    }
    return msg;
  },
};

//========================================//
//          JSON Encode / Decode          //
//========================================//

export const SORT_BYJSON = {
  UNSORTED: "UNSORTED",
  NAME: "NAME",
  REPOSITORY: "REPOSITORY",
  VERSION: "VERSION",
  /**
   * @private
   */
  _fromInt: function (i: number): SORT_BY {
    switch (i) {
      case 0: {
        return "UNSORTED";
      }
      case 1: {
        return "NAME";
      }
      case 2: {
        return "REPOSITORY";
      }
      case 3: {
        return "VERSION";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as SORT_BY;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: SORT_BY): number {
    switch (i) {
      case "UNSORTED": {
        return 0;
      }
      case "NAME": {
        return 1;
      }
      case "REPOSITORY": {
        return 2;
      }
      case "VERSION": {
        return 3;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const FILTER_TYPEJSON = {
  NO_FILTER: "NO_FILTER",
  IN_REPOSITORY: "IN_REPOSITORY",
  SUPPORTS_ARCH: "SUPPORTS_ARCH",
  /**
   * @private
   */
  _fromInt: function (i: number): FILTER_TYPE {
    switch (i) {
      case 0: {
        return "NO_FILTER";
      }
      case 1: {
        return "IN_REPOSITORY";
      }
      case 2: {
        return "SUPPORTS_ARCH";
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as FILTER_TYPE;
      }
    }
  },
  /**
   * @private
   */
  _toInt: function (i: FILTER_TYPE): number {
    switch (i) {
      case "NO_FILTER": {
        return 0;
      }
      case "IN_REPOSITORY": {
        return 1;
      }
      case "SUPPORTS_ARCH": {
        return 2;
      }
      // unknown values are preserved as numbers. this occurs when new enum values are introduced and the generated code is out of date.
      default: {
        return i as unknown as number;
      }
    }
  },
} as const;

export const SearchRequestJSON = {
  /**
   * Serializes SearchRequest to JSON.
   */
  encode: function (msg: Partial<SearchRequest>): string {
    return JSON.stringify(SearchRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes SearchRequest from JSON.
   */
  decode: function (json: string): SearchRequest {
    return SearchRequestJSON._readMessage(
      SearchRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes SearchRequest with all fields set to their default value.
   */
  initialize: function (): SearchRequest {
    return {
      query: "",
      limit: 0n,
      sortBy: SORT_BY._fromInt(0),
      filterType: FILTER_TYPE._fromInt(0),
      filterValue: undefined,
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SearchRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.query) {
      json["query"] = msg.query;
    }
    if (msg.limit) {
      json["limit"] = msg.limit.toString();
    }
    if (msg.sortBy && SORT_BYJSON._toInt(msg.sortBy)) {
      json["sortBy"] = msg.sortBy;
    }
    if (msg.filterType && FILTER_TYPEJSON._toInt(msg.filterType)) {
      json["filterType"] = msg.filterType;
    }
    if (msg.filterValue != undefined) {
      json["filterValue"] = msg.filterValue;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SearchRequest, json: any): SearchRequest {
    const _query_ = json["query"];
    if (_query_) {
      msg.query = _query_;
    }
    const _limit_ = json["limit"];
    if (_limit_) {
      msg.limit = BigInt(_limit_);
    }
    const _sortBy_ = json["sortBy"] ?? json["sort_by"];
    if (_sortBy_) {
      msg.sortBy = _sortBy_;
    }
    const _filterType_ = json["filterType"] ?? json["filter_type"];
    if (_filterType_) {
      msg.filterType = _filterType_;
    }
    const _filterValue_ = json["filterValue"] ?? json["filter_value"];
    if (_filterValue_) {
      msg.filterValue = _filterValue_;
    }
    return msg;
  },
};

export const StringListJSON = {
  /**
   * Serializes StringList to JSON.
   */
  encode: function (msg: Partial<StringList>): string {
    return JSON.stringify(StringListJSON._writeMessage(msg));
  },

  /**
   * Deserializes StringList from JSON.
   */
  decode: function (json: string): StringList {
    return StringListJSON._readMessage(
      StringListJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes StringList with all fields set to their default value.
   */
  initialize: function (): StringList {
    return {
      entries: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<StringList>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.entries?.length) {
      json["entries"] = msg.entries;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: StringList, json: any): StringList {
    const _entries_ = json["entries"];
    if (_entries_) {
      msg.entries = _entries_;
    }
    return msg;
  },
};

export const PackageJSON = {
  /**
   * Serializes Package to JSON.
   */
  encode: function (msg: Partial<Package>): string {
    return JSON.stringify(PackageJSON._writeMessage(msg));
  },

  /**
   * Deserializes Package from JSON.
   */
  decode: function (json: string): Package {
    return PackageJSON._readMessage(PackageJSON.initialize(), JSON.parse(json));
  },

  /**
   * Initializes Package with all fields set to their default value.
   */
  initialize: function (): Package {
    return {
      name: "",
      repository: "",
      version: "",
      release: 0n,
      epoch: undefined,
      description: undefined,
      homepage: undefined,
      maintainer: undefined,
      architectures: [],
      licenses: [],
      provides: [],
      conflicts: [],
      replaces: [],
      depends: {},
      buildDepends: {},
    };
  },

  /**
   * @private
   */
  _writeMessage: function (msg: Partial<Package>): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.repository) {
      json["repository"] = msg.repository;
    }
    if (msg.version) {
      json["version"] = msg.version;
    }
    if (msg.release) {
      json["release"] = msg.release.toString();
    }
    if (msg.epoch != undefined) {
      json["epoch"] = msg.epoch.toString();
    }
    if (msg.description != undefined) {
      json["description"] = msg.description;
    }
    if (msg.homepage != undefined) {
      json["homepage"] = msg.homepage;
    }
    if (msg.maintainer != undefined) {
      json["maintainer"] = msg.maintainer;
    }
    if (msg.architectures?.length) {
      json["architectures"] = msg.architectures;
    }
    if (msg.licenses?.length) {
      json["licenses"] = msg.licenses;
    }
    if (msg.provides?.length) {
      json["provides"] = msg.provides;
    }
    if (msg.conflicts?.length) {
      json["conflicts"] = msg.conflicts;
    }
    if (msg.replaces?.length) {
      json["replaces"] = msg.replaces;
    }
    if (msg.depends) {
      const _depends_ = Object.fromEntries(
        Object.entries(msg.depends)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(PackageJSON.Depends._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_depends_).length > 0) {
        json["depends"] = _depends_;
      }
    }
    if (msg.buildDepends) {
      const _buildDepends_ = Object.fromEntries(
        Object.entries(msg.buildDepends)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(PackageJSON.BuildDepends._writeMessage)
          .map(({ key, value }) => [key, value])
      );
      if (Object.keys(_buildDepends_).length > 0) {
        json["buildDepends"] = _buildDepends_;
      }
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: Package, json: any): Package {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _repository_ = json["repository"];
    if (_repository_) {
      msg.repository = _repository_;
    }
    const _version_ = json["version"];
    if (_version_) {
      msg.version = _version_;
    }
    const _release_ = json["release"];
    if (_release_) {
      msg.release = BigInt(_release_);
    }
    const _epoch_ = json["epoch"];
    if (_epoch_) {
      msg.epoch = BigInt(_epoch_);
    }
    const _description_ = json["description"];
    if (_description_) {
      msg.description = _description_;
    }
    const _homepage_ = json["homepage"];
    if (_homepage_) {
      msg.homepage = _homepage_;
    }
    const _maintainer_ = json["maintainer"];
    if (_maintainer_) {
      msg.maintainer = _maintainer_;
    }
    const _architectures_ = json["architectures"];
    if (_architectures_) {
      msg.architectures = _architectures_;
    }
    const _licenses_ = json["licenses"];
    if (_licenses_) {
      msg.licenses = _licenses_;
    }
    const _provides_ = json["provides"];
    if (_provides_) {
      msg.provides = _provides_;
    }
    const _conflicts_ = json["conflicts"];
    if (_conflicts_) {
      msg.conflicts = _conflicts_;
    }
    const _replaces_ = json["replaces"];
    if (_replaces_) {
      msg.replaces = _replaces_;
    }
    const _depends_ = json["depends"];
    if (_depends_) {
      msg.depends = Object.fromEntries(
        Object.entries(_depends_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(PackageJSON.Depends._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    const _buildDepends_ = json["buildDepends"] ?? json["build_depends"];
    if (_buildDepends_) {
      msg.buildDepends = Object.fromEntries(
        Object.entries(_buildDepends_)
          .map(([key, value]) => ({ key: key as any, value: value as any }))
          .map(PackageJSON.BuildDepends._readMessage)
          .map(({ key, value }) => [key, value])
      );
    }
    return msg;
  },

  Depends: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Package.Depends>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = StringListJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (msg: Package.Depends, json: any): Package.Depends {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = StringList.initialize();
        StringListJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },

  BuildDepends: {
    /**
     * @private
     */
    _writeMessage: function (
      msg: Partial<Package.BuildDepends>
    ): Record<string, unknown> {
      const json: Record<string, unknown> = {};
      if (msg.key) {
        json["key"] = msg.key;
      }
      if (msg.value) {
        const _value_ = StringListJSON._writeMessage(msg.value);
        if (Object.keys(_value_).length > 0) {
          json["value"] = _value_;
        }
      }
      return json;
    },

    /**
     * @private
     */
    _readMessage: function (
      msg: Package.BuildDepends,
      json: any
    ): Package.BuildDepends {
      const _key_ = json["key"];
      if (_key_) {
        msg.key = _key_;
      }
      const _value_ = json["value"];
      if (_value_) {
        const m = StringList.initialize();
        StringListJSON._readMessage(m, _value_);
        msg.value = m;
      }
      return msg;
    },
  },
};

export const GetPackageRequestJSON = {
  /**
   * Serializes GetPackageRequest to JSON.
   */
  encode: function (msg: Partial<GetPackageRequest>): string {
    return JSON.stringify(GetPackageRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetPackageRequest from JSON.
   */
  decode: function (json: string): GetPackageRequest {
    return GetPackageRequestJSON._readMessage(
      GetPackageRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetPackageRequest with all fields set to their default value.
   */
  initialize: function (): GetPackageRequest {
    return {
      name: "",
      repository: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetPackageRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.repository) {
      json["repository"] = msg.repository;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetPackageRequest,
    json: any
  ): GetPackageRequest {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _repository_ = json["repository"];
    if (_repository_) {
      msg.repository = _repository_;
    }
    return msg;
  },
};

export const SearchResponseJSON = {
  /**
   * Serializes SearchResponse to JSON.
   */
  encode: function (msg: Partial<SearchResponse>): string {
    return JSON.stringify(SearchResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes SearchResponse from JSON.
   */
  decode: function (json: string): SearchResponse {
    return SearchResponseJSON._readMessage(
      SearchResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes SearchResponse with all fields set to their default value.
   */
  initialize: function (): SearchResponse {
    return {
      packages: [],
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<SearchResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.packages?.length) {
      json["packages"] = msg.packages.map(PackageJSON._writeMessage);
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (msg: SearchResponse, json: any): SearchResponse {
    const _packages_ = json["packages"];
    if (_packages_) {
      for (const item of _packages_) {
        const m = Package.initialize();
        PackageJSON._readMessage(m, item);
        msg.packages.push(m);
      }
    }
    return msg;
  },
};

export const GetBuildScriptRequestJSON = {
  /**
   * Serializes GetBuildScriptRequest to JSON.
   */
  encode: function (msg: Partial<GetBuildScriptRequest>): string {
    return JSON.stringify(GetBuildScriptRequestJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetBuildScriptRequest from JSON.
   */
  decode: function (json: string): GetBuildScriptRequest {
    return GetBuildScriptRequestJSON._readMessage(
      GetBuildScriptRequestJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetBuildScriptRequest with all fields set to their default value.
   */
  initialize: function (): GetBuildScriptRequest {
    return {
      name: "",
      repository: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetBuildScriptRequest>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.name) {
      json["name"] = msg.name;
    }
    if (msg.repository) {
      json["repository"] = msg.repository;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetBuildScriptRequest,
    json: any
  ): GetBuildScriptRequest {
    const _name_ = json["name"];
    if (_name_) {
      msg.name = _name_;
    }
    const _repository_ = json["repository"];
    if (_repository_) {
      msg.repository = _repository_;
    }
    return msg;
  },
};

export const GetBuildScriptResponseJSON = {
  /**
   * Serializes GetBuildScriptResponse to JSON.
   */
  encode: function (msg: Partial<GetBuildScriptResponse>): string {
    return JSON.stringify(GetBuildScriptResponseJSON._writeMessage(msg));
  },

  /**
   * Deserializes GetBuildScriptResponse from JSON.
   */
  decode: function (json: string): GetBuildScriptResponse {
    return GetBuildScriptResponseJSON._readMessage(
      GetBuildScriptResponseJSON.initialize(),
      JSON.parse(json)
    );
  },

  /**
   * Initializes GetBuildScriptResponse with all fields set to their default value.
   */
  initialize: function (): GetBuildScriptResponse {
    return {
      script: "",
    };
  },

  /**
   * @private
   */
  _writeMessage: function (
    msg: Partial<GetBuildScriptResponse>
  ): Record<string, unknown> {
    const json: Record<string, unknown> = {};
    if (msg.script) {
      json["script"] = msg.script;
    }
    return json;
  },

  /**
   * @private
   */
  _readMessage: function (
    msg: GetBuildScriptResponse,
    json: any
  ): GetBuildScriptResponse {
    const _script_ = json["script"];
    if (_script_) {
      msg.script = _script_;
    }
    return msg;
  },
};
